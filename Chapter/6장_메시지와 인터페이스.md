# 6장. 메시지와 인터페이스

객체지향 프로그래밍에 대한 가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것이다. → 전체 개발 활동의 중심에 클래스를 놓는다. 

⇒ 클래스라는 구현 도구에 지나치게 집착하면 경직되고 유연하지 못한 설계에 이를 확률이 높아진다. 

<br>

**객체를 지향하자 : 객체가 수행하는 책임에 초점을 두자**

- 객체지향 애플리케이션의 가장 중요한 재료는 클래스가 아니라 **객체들이 주고받는 메시지**이다.
    
    ⇒ 클래스 사이의 정적인 관계에서 메시지 사이의 동적인 흐름으로 초점을 전환하는 것은 미숙함을 벗어나 숙련된 객체지향을 하게 한다. 
    

<br>

객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다. ⇒ 책임 주도 설계 방법을 따르는 것 만으로는 부족하다. 

<br>

## 01. 협력과 메시지
### +클라이언트-서버 모델

**메시지**

- 객체사이의 협력을 가능하게 하는 매개체이다.
- 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것이다.

<br>

두 객체 사이의 협력관계를 설명하기 위해 사용하는 전통적인 메타포는 클라이언트-서버 모델이다. 

- 클라이언트 : 협력안에서 메시지를 전송하는 객체
- 서버 : 메시지를 수신하는 객체 

<br>

협력은 클라이언트가 서버의 서비스를 요청하는 **단방향 상호작용**이다. 

<br>

Screening(클라이언트)는 *가격을 계산하라*는 메시지를 전송함으로써 도움을 요청하고 Movie(서버)는 가격을 계산하는 서비스를 제공하며 메시지에 응답한다.

최종예매요금을 계산하고 할인요금을 계산하기 위해 Movie(클라이언트)는 *할인요금을 계산하라*는 메시지를 DiscountPolicy(서버)에 전송해 할인요금을 반환받는다. 

⇒ 객체는 협력에 참여하는 동안 **클라이언트와 서버의 역할을 동시에 수행하는 것이 일반적**이다. 

<br>

협력의 관점에서 객체는 두가지 종류의 메시지 집합으로 구성된다.

- 객체가 수신하는 메시지의 집합
- 객체가 외부의 객체에 전송하는 메시지 집합

⇒ 대부분 수신하는 메시지 집합에만 초점을 맞추지만 **외부에 전송하는 메시지의 집합**도 함께 고려하는 것이 바람직하다. 

<br>

요점은 객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다는 것이다. → 그걸 가능하게 해주는 매게체가 **메시지**이다.

<br>

### + 메시지와 메시지 전송

메시지는 오퍼레이션 명(operation name) 과 인자(argument)로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다.

<br>

**메시지 전송**

java : condition.isSatisfiedBy(screening)

condition이 메시지 수신자, isSatisfiedBy(screening)이 메시지(오퍼레이션명 + 인자)이다. 

<br>

### + 메시지와 메서드

메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인지에 달려있다. 메시지 수신자 condition은 인터페이스 타입으로 정의 되어있지만 실제로 실행되는 코드는 인터페이스를 **실체화한 클래스의 종류에 따라 달라진다.** 

=>메시지를 수신했을 때 실제로 실행되는 함수를 **메서드**라고 부른다. 

<br>

- 전통적인 방식의 개발자는 어떤 코드가 실행될지를 정확하게 알고 있는 상황에서 함수호출이나 프로시저 호출 구문을 작성함
- 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행시점에 연결해야하기 때문에 **컴파일 시점과 실행 시점의 의미가 달라질 수 있다.**

<br>

메시지와 메서드 구분은 메시지 전송자와 메시지 수신자가 **느슨하게 결합**될 수 있게 한다. 

⇒ 전송자는 어떤 메시지를 전송하는지만 알면된다. 수신자 역시 누가 전송하는지 알 필요가 없다. 

<br>

### + 퍼블릭 인터페이스와 오퍼레이션

**퍼블릭 인터페이스** : 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합

**오퍼레이션** : 퍼블릭 인터페이스에 포함된 메시지 

오퍼레이션은 수행 가능한 어떤 행동에 대한 *추상화*이다. 흔히 오퍼레이션이라고 부를 떄는 내부의 구현코드는 제외하고 단순한 메시지와 관련된 시그니쳐를 가리키는 경우가 대부분이다. ⇒ DiscountCondition인터페이스에 정의된 isSatisiedBy

메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다. ⇒SequenceCondition과 PeriodCondition의 isSatisfiedBy

<br>

프로그래밍 언어에서 관점은

**1)** 객체가 다른 객체에게 메시지를 전송하면 

**2)** 런타임 시스템은 메시지 전송을 오퍼레이션 호출로 해석하고 

**3)** 메시지를 수신한 객체의 실제 타입을 기반으로 

**4)** 적절한 메서드를 찾아 실행한다. 

⇒ 따라서 퍼블릭 인터페이스와 메시지의 관점에서 보면 메서드 호출보다는 오퍼레이션 호출이라는 용어를 사용하는 것이 더 적절하다.

<br>

### +시그니처

오퍼레이션의 이름과 파라미터 목록을 합쳐 **시그니처**라고 부른다.

**오퍼레이션**은 실행코드 없이 시그니처만을 정의한 것이다

**메서드**는 이 시그니처에 구현을 더한 것이다. 

<br>

다형성을 위해 하나의 오퍼레이션에 대해 다양한 메서드를 구현해야한다. 

→ 오퍼레이션의 관점에서 다형성이란 동일한 오퍼레이션 호출에 대해 서로 다른 메서드들이 실행되는 것 이라고 정의할 수 있다. 

중요한 것은 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다는 것이다, → 객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 **메시지가 객체의 품질을 결정한다**고 할 수 있다. 

<br>

## 02. 인터페이스와 설계 품질

좋은 인터페이스는 **최소한의 인터페이스**와 **추상적인 인터페이스**라는 조건을 만족해야한다. 

이 조건을 지키며 설계할 수 있는 가장 좋은 방법은 책임 주도 설계 방법을 따르는 것이다. 

→ 메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스미는 것을 방지한다. 

→ 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현할 수 있게 한다. 

<br>

퍼블릭 인터페이스의 품질에 영향을 미치는 다음과 같은 원칙과 기법을 알아보자

- 디미터 법칙
- 묻지 말고 시켜라
- 의도를 드러내는 인터페이스
- 명령-쿼리 분리


<br>

### 디미터 법칙

다음 코드는 4장서 살펴본 절차적인 방식의 영화 예매 시스템 코드 중에서 할인 가능 여부를 체크하는 코드를 가져온 것이다

```java
public class ReservationAgency{
	public Reservation reserve(Screening screening. Customer customer, int audienceCount){
		Movie = screening.getMovie();
		
		boolean discountable =false;
		for(DiscountCondition condition :movie.getDiscountConditions()){
			discountable= screening.getWhenScreened().getDatOfWeek().equals(condition.getDayOfWeek()&& ...)
			...
		}
	}

}
```

이 코드의 가장 큰 단점은 Screening 과의 결합도가 너무 높다는 것이다. 

문제의 원인은 ReservationAgency가 Screening 뿐만 아니라 Movie와 DiscountCondition에도 직접 접근하기 때문이다.

⇒ ReservationAgency는 사소한 변경에도 이리저리 흔들리는 의존성의 집결지이다. 

<br>

객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 디미터 법칙이다. 

<br>

**디미터 법칙**

- 낯선 자에게 말하지 마라 , 오직 인접한 이웃하고만 말하라
    
    도트(.)으로 메시지 전송을 표현하는 언어에는 오직 하나의 도트만 사용하라라는 말로 요약되기도 한다. 
    
- 디미터 법칙을 따르기 위해서는 클래스가 **특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍**해야한다.
- 모든 클래스 c와 c에 구현된 모든 메서드 m에 대해서 , m이 메시지를 전송할 수 있는 모든 객체는 다음에 서술된 클래스의 인스턴스여야 한다. 이때 m에 의해 생성된 객체나 m이 호출하는 메서드에 의해 생성된 객체, 전역 변수로 선언된 객체는 모두 m의 인자로 간주한다.
    
    → this객체, 매서드의 매개변수, this의 속성인 컬렉션의 요소, 메서드 내에서 생성된 지역 객체 
    

<br>

결합도 문제를 해결하기 위해 수정한 **ReservationAgency** 코드는 다음과 같다. 

```java
public class ReservationAgency{
	public Reservation reserve(Screening screening, Customer customer, int audienceCount){
		Money fee = screening.caculateFee(audienceCount);
		return new Reservation(customer,screening,fee,audienceCount);
	}

}
```

이 코드에서 ReservationAgency는 메서드의 인자로 전달된 Screening 인스턴스에게만 메시지를 전송한다. ReservationAgency는 Screening 내부에 대한 **어떤 정보도 알지 못한다.**

<br>

디미터 법칙을 따르면 **부끄럼타는 코드**를 작성할 수 있다. 

→ 부끄럼타는 코드란 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다. ⇒ 따라서 클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다. 

<br>

<br>

다음은 디미터 법칙을 **위반**하는 코드의 전형적인 모습이다. 

```java
screening.getMovie().getDiscountCondition();
```

흔히 이와 같은 코드를 **기차충돌**이라고 부른다.

기차 충돌은 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.

**⇒ 캡슐화는 무너지고, 메시지 전송자가 메시지 수신자의 내부구현에 강하게 결합된다.** 

<br>

```java
screening.caculateFee(audienceCount);
```

디미터 법칙을 따르도록 수정한 코드이다.

디미터 법칙은 정보 처리하는데 필요한 책임을 정보를 알고 있는 객체에게 할당하기 때문에 **응집도가 높은 객체가 만들어진다.**

⇒ 하지만 무비판적으로 이 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수 있다. 

<br>

디미터 법칙은 객체의 내부구조를 묻는 메시지가 아니라 수신자에게 무언가를 시키는 메시지가 더 좋은 메시지라고 속삭인다. 

<br>

**+) 디미터 법칙과 캡슐화**

디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다.

캡슐화 원칙이 클래스 내부의 구현을 감춰야한다는 사실을 강조한다면 **디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야하는 요소를 제한한다.**

⇒ 디미터 법칙은 협력과 구현이라는 사뭇 달라 보이는 두 가지 문맥을 하나의 유기적인 개념으로 통합한다.

<br>

### 묻지 말고 시켜라

디미터 법칙은 **훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야한다**는 사실을 강조한다. ⇒ 묻지말고 시켜라(Tell, Don’t Ask) 는 이런 스타일의 메시지 작성을 장려하는 용어이다. 

메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안된다.

객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다. 

<br>

객체지향의 기본은 **함께 변경될 확률이 높은 정보와 행동**을 하나의 단위로 통합하는 것이다. 

→ 묻지말고시켜라 원칙에 따르면 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에 자연스럽게 정보와 행동을 **동일한 클래스 안**에 두게 된다. 

⇒ 이 원칙대로 메시지를 결정하게 되면 자연스럽게 정보 전문가에게 책임을 할당하게 되고 높은 응집도를 가질 가능성이 높아진다. 

<br>

묻지 말고 시켜라 원칙과 디미터 법칙은 훌륭한 인터페이스를 제공하기 위해 포함해야하는 오퍼레이션에 대한 **힌트**를 제공한다. 

→**내부의 상태를 묻는 오퍼레이션**을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고민해봐야한다. 

→ 내부의 상태를 이용해 어떤 결정을 내리는 로직이 **객체 외부에 존재**한다면 그건 해당 객체가 책임져야하는 어떤 행동이 객체 외부로 누수된 것이다. 

<br>

상태를 묻는 오퍼레이션 → **행동을 요청**하는 오퍼레이션으로 대체하여 인터페이스를 향상시켜라 

객체는 자신이 내부적으로 보유하고 있는 정보나 메시지 전송의 결과로 얻게되는 정보만 사용해서 의사결정을 내리게 되면 다른 객체의 내부를 탐색하지 않아도 된다. 

⇒ 이 스타일을 따르지 않을경우 기차충돌로 보여지는 코드가 만들어진다. (getter)

<br>

단순하게 객체에게 묻지 않고 시킨다고 해서 모든 문제가 해결되는 것은 아니다. 

→ 객체가 어떻게 작업을 수행하는지를 노출해서는 안되며, 인터페이스는 객체가 어떻게하는지가 아니라 **무엇을 하는지**를 서술해야한다.

<br>

### 의도를 드러내는 인터페이스

smalltalk best practive patterns에서 캔트백은 메서드를 명명하는 방법에 대해 2가지 방법을 설명했다. 

**1. 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름을 짓는 것**

→ 메서드의 이름은 내부의 구현 방법을 드러낸다. 

```java
public class PeriodCondition{
	publuc boolean isSatiedfiedByPeriod(Screening screening)
}
public class SequenceCondition{
	publuc boolean isSatiedfiedBySequence(Screening screening)
}
```
    

이러한 스타일이 좋지 않은 이유 2가지 

- 메서드에 대해 제대로 커뮤니케이션 하지 못한다. : 클라이언트 관점에서 두 클래스는 모두 할인 조건을 판단하기 위해 동일한 작업을 수행함 but, 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행하다는 사실을 알아채기 어렵다
- 메서드 수준에서 캡슐화를 위반한다. → 클라이언트로 하여금 협력하는 객체의 종류를 알도록 강요한다.
    
    ⇒ 할인여부 판단 방법이 바뀌면 메서드 이름 변경 필요, 
    
    ⇒ PeriodCondition에서 SequenceCondition로 바뀔때, 객체 변경뿐만 아니라 호출하는 메서드 변경 필요 


<br>

**2. “어떻게”가 아니라 “무엇”을 하는지 드러내는 것이다.**

**어떻게** 수행하는지를 드러내는 이름이란 메서드의 내부 구현을 설명하는 이름이다. 

→ 설계시점부터 내부구현에 대해 고민이 된다. 

**무엇**을 하는지 드러내도록 메서드의 이름을 짓기 위해서는 객체가 협력안에서 수행해야하는 책임에 관해 고민해야한다. 

→ 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만듬 ⇒ 결과적으로 협력하는 클라이언트의 의도에 부합한 메서드의 이름을 짓게 됨

<br>
    
**인터페이스를 생성**하고 두 메서드를 동일한 방식으로 사용할 수 있게 하자 
    
```java
publuc interface DiscountCondition {
	boolean isSatisfied
}
```

```java
public class PeriodCondition implements DiscountCondition{
	publuc boolean DiscountCondition(Screening screening)
}
public class SequenceCondition implements DiscountCondition{
	publuc boolean DiscountCondition(Screening screening)
}
```
    
어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을 **의도를 드러내는 선택자**라고 부른다. 

<도메인 주도설계>에서 에릭 에반스는 켄트 벡의 의도를 드러내는 선택자를 이터페이스 레벨로 확장한 의도를 드러내는 인터페이스를 제시했다. 

⇒ 구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야한다는 것이다. 

<br>

_“방정식 푸는 방법을 제시하지 말고 공식으로 표현하라, 문제를 내라, 하지만 문제를 푸는 방법을 표현해서는 안된다.”_

<br>

### 함께 모으기

디미터 법칙을 위반하는 티켓 판매 도메인

```java
public class Theater{
	private TicketSeller ticketSeller;
	
	//생성자
	
	public void enter(Audience audience){
		if(audience.getBag().hasInvitation()){
			Ticket ticket = ticketSeller.getTicketOffice().getTicket();
			audience.getBag().setTicket(ticket);
		}else{
			Ticket ticket = ticketSeller.getTicketOffice().getTicket();
			audience.getBag().minusAmount(ticket.getFee());
			...
		}
	
	}

}
```

위의 코드는 1장에서 나왔던 티켓 판매 도메인이다. 

 Theater 인자로 전달된 audience와 인스턴스 변수인 tickeSeller에게 메시지를 전송하는 것은 문제가 없다. 

<br>

하지만, audience와  ticketSeller내부에 포함된 객체도 직접 접근한다. 

⇒ **디미터 법칙 위반 !**

<br>

또한 audience내부에 있는 Bag에게도 메시지를 전송한다. 

⇒ Theater과 Audience는 퍼블릭 인터페이스 뿐만 아니라 **내부 구조에 대해서도 결합**된다 .

<br>

<br>


근본적으로 디미터 법칙을 위반하는 설계는 인터페이스와 구현의 분리 원칙을 위반한다. 

기억해야할 점은 객체의 내부구조는 구현에 해당한다 .

→ Audience가 Bag을 포함한다는 사실은 Audience의 내부 구현에 속하며, Audience는 자신의 내부 구현을 자유롭게 변경할수 있어야 한다. 

⇒ 하지만, 퍼블릭 인터페이스에 getBag을 포함시키며 **외부로 새어나갔다**. 클라이이언트에게 구현을 노출한다는 것을 의미하며, **불안정한 코드를 얻게 된다.**

<br>

디미터 법칙을 위반한 코드는 사용하기도 어렵다. Audience의 퍼블릭 인터페이스뿐만 아니라 Audience의 내부 구조까지 속속들이 알고 있어야하기 때문이다. 

⇒ Theater는 TicketSeller가 getTicketOffice메시지를 수신할 수 있다는 사실 

⇒ 내부의 TicketOffice를 포함하고 있다는 사실

⇒TicketOffice가 getTicket메시지를 수신할 수 있으며, 이 메서드가 반환하는 Ticket인스턴스가 getFee메시지를 이해할 수 있다는 사실

들을 알고 있어야한다.  

<br>

수정하는 방법은 Audience와 TicketSeller가 **직접 자신의 책임을 수행하도록 하자**

<br>

**[묻지말고 시켜라]** 

Theater는 내부구조에 관해 묻지 말고 원하는 작업을 시켜야한다. 

Theater가 TicketSeller에게 시키고 싶은 일은 Audience가 Ticket을 가지도록 만드는 것이므로 TicketSeller에 setTicket 메서드를 추가하고 enter메서드의 로직을 setTicket안으로 이동하자

```java
public class Theater{
	public void ener(Audience audience){
		ticketSeller.setTicket(audience);
	}
}
```

Theater는 TicketSeller에게 메시지를 전송하게 했다.

TicketSeller는 Audience가 Ticket을 보유하도록 만드는 것이다. 

```java
public class Audience{
	public Long setTicket(Ticket ticket){
		retrun setTicket(ticket);
	}
}
```

```java
public class Bag{
	public Long setTicket(Ticket ticket){
		if(hasInivtation()){
			this.ticket = ticket;
			return 0L;
		}else{
			this.ticket = ticket;
			minusSount(ticket.getFee());
			...
		}
	}
	private boolean hasInvitation(){...}
	private void minusAmount(Long amount){...}
}
```

이렇게 수정하며 Audience는 자신의 상태를 스스로 관리하고 결정하는 자율적인 존재가 되었다. 

- 구현이 객체의 퍼블릭 인터페이스에 노출되지 않기 때문에 객체 사이의 결합도는 낮아졌다 .
- 응집도가 높아졌다.

<br>

**[인터페이스의 의도를 드러내자]** 

현재의 인터페이스는 클라이언트의 의도를 명확하게 드러내지 못한다. 

⇒ Audience의 setTicket 메서드가 의도한 것은 무엇인가, Bag의 setTicket메서드는 이름이 같은 앞의 두 메서드와 동일한 의도를 드러내나? **NO**

<br>

Theater가 TicketSeller에게 setTicket메시지를 전송해서 얻고 싶었던 결과는 Audience에게 티켓을 판매하는 것이다. 

⇒ 따라서 sellTicket보다 **sellTo**가 의도를 더 명확하게 표현하는 메시지라고 할 수 있다. 

⇒ Bag또한 보관하는 것이 목적이므로 **hold**라고 변경하는 것이 좋을것이다. 

⇒ Audience는 구매하는 것이 목적이므로 **buy**라고 변경하는 것이 좋을 것이다.
