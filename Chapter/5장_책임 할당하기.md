# 5장. 책임 할당하기

책임 할당 과정은 일종의 트레이드오프 활동이다. 동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라진다. 

<br>

## 01. 책임 주도 설계를 위해

데이터 중심 설계 → 책임 주도 설계로 전환하기 위해 따라야하는 원칙

- 데이터 보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

<br>

### + 데이터보다 행동을 먼저 결정하라

객체에게 중요한 것은 **외부에 제공하는 행동**이다. 

클라이언트 관점에서 객체가 수행하는 행동이란 곧 **객체의 책임**을 의미한다.

데이터는 객체가 책임을 수행하는 데 필요한 재료를 제공할 뿐이다.

<br>

**[객체의 데이터에서 행동으로 무게 중심을 옮기기 위한 기법]**

→ 객체를 설계하기 위한 질문이 순서를 바꾸기 

“이 객체가 포함해야하는 데이터가 무엇인가”→ “데이터를 처리하는데 필요한 오퍼레이션은 무엇인가”

책임 중심의 설계에서는 객체의 행동, 즉 *책임을 먼저 결정한 후에 객체의 상태를 결정*한다.

<br>

### +협력이라는 문맥 안에서 책임을 결정하라

**객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다.**

→ 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 것이다.

→ 책임이 조금 어색해 보이더라도 협력에 적합하다면 그 책임은 좋은 것이다. 
<br>

협력에 적합한 책임이란 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미함

→ 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 한다.

<br>

**메시지를 결정한 후에 객체를 선택하라**

메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요한 것이다. 
⇒ 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.
메시지가 **클라이언트의 의도를 표현**한다

- 클라이언트는 단지 임의의 객체가 메시지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메시지를 전송할 뿐이다.
- 그리고 메시지를 수신하기로 결정된 객체는 메시지를 처리할 책임을 할당받게 된다.

⇒ 메시지 전송자의 관점에서는 메시지 수신자가 깔끔하게 **캡슐화**되는것이다. 

책임중심의 설계가 응집도가 높고 결합도가 낮으며 변경하기 쉽다고 말하는 이유가 여기에 있다. 

<br>

**객체에게 적절한 책임을 할당하기 위해서는 협력이라는 문맥을 고려해야한다.**

협력이라는 문맥에서 적절한 책임이란 곧 클라이언트의 관점에서 적절한 책임을 의미한다. 

⇒ 3장에서 소개한 **책임 주도 설계 방법**의 핵심과 거의 동일하다 !

<br>

### + 책임 주도 설계

3장에서 나온 책임 주도 설계의 흐름

- 시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다
- 시스템 책임을 더 작은 책임으로 분할한다
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 하당한다
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.

<br>

### +정보 전문가에게 책임을 할당하라

: 책임 주도 설계 방식에서의 첫 단계는 애플리케이션이 제공해야하는 기능을 애플리케이션의 책임으로 생각하는 것이다. 

→ 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고, 이 메시지를 첫번째 객체를 선택하는 것으로 설계 시작

<br>

<br>

## 02. 책임할당을 위한 GRASP 패턴

**GRASP** : General Responsibility Assignment Software Pattern (**일반적인 책임할당을 위한 소프트웨어 패턴**)

<br>

### +도메인 개념에서 출발하기

: 도메인 안에는 무수히 많은 개념들이 존재하며 이 도메인 개념들을 책임 할당의 대상으로 사용하면 코드에 도메인 모습을 투영하기가 좀 더 수월해진다. 

: 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다.

: 도메인 개념을 정리하는데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행하라
 앞서 나온 영화 예매 시스템을 생각해보자

: 사용자에게 제공해야하는 기능은 영화를 예매하는 것이다.  ⇒ 애플리케이션은 영화를 예매할 책임이 있다. 

이제 이 책임을 수행하는데 필요한 메시지를 결정해야한다. (메시지를 전송할 객체의 의도를 반영해서 결정)

1. 메시지를 전송할 객체는 무엇을 원하는가 ⇒ **“예매하라”**
2. 메시지를 수신하 적합한 객체는 누구인가

이 질문에 답하기 위해 객체가 상태와 행동을 통합한 캡슐화의 단위라는것에 집중해야한다. 

→ 자신의 상태를 스스로 처리하는 자율적인 존재여야한다. 

<br>

**객체에게 책임을 할당하는 첫번째 원칙 : INFORMATION EXPERT (정보 전문가) 패턴**

객체의 책임과 책임을 수행하는데 필요한 상태는 동일한 객체 안에 존재해야한다.

⇒ **책임을 수행할 정보를 알고있는 객체에게 책임을 할당하는 것**이다. 

- 정보와 행동을 최대한 가까운 곳에 위치시키기 때문에 캡슐화 유지 가능
- 필요한 정보를 가진 객체들로 책임이 분산되기 때문에 더 응집력있고 이해하기 쉬워짐
- 결합도가 낮아져서 간결하고 유지보수하기 쉬운 시스템 구축 가능
- 책임을 수행하는 객체가 정보를 알고있다고 해서 그 정보를 저장할 필요는 없다 → 정보를 제공하는 객체를 알고 있거나 계산을 통해 제공할 수도 있다.

<br>

예매하는데 필요한정보를 가장 많이 알고있는 **Screening이라는 객체에 *예매하라* 를 할당**해야한다. 

예매하라를 처리하기 위해서는 예매 가격을 계산해야하고 Screening은 가격을 계산하는데 필요한 정보를 모르기 때문에 외부객체에 도움을 요청해서 가격을 얻어야한다. 

  ⇒ ***계산하라***

계산을 처리하기 위해 **할인 여부를 판단**해야하고 위 방식과 동일하게 진행된다 .

<br>


### +높은 응집도와 낮은 결합도

설계는 트레이드오프 활동이다. → 동이한 기능을 구현할 수 있는 무수한 설계가 존재하고 이 중 한 가지를 선택해야하는 경우가 빈번함

위에서는 Movie가 할인 여부를 판단하라는 메시지를 전송한다. 

→ Screening이 DiscountCondition과 협력하는것은 어떨까 

⇒ Screening에서 할인 여부를 판단하라는 메시지를 전송하고, 반환받은 할인여부를 Movie에 인자로 전달하는 것이다. 이 전달받은 값을 이용해 할인정책을 적용하여 계산하는지 결정하는 것이다. 

<br>

**LOW COUPLING (낮은 결합도) 패턴과 HIGH COHESION ( 높은 응집도) 패턴**

1. 도메인상으로는 Movie가 DiscountCondition 목록을 포함하고 있어 결합도를 추가하지 않고 협력가능하다 
2. Screening이 DiscountCondition과 협력하게 되면 새로운 결합도가 추가된다. 

⇒ **결합도 관점에서는 1번이 나은 대안이다.** 

<br>

1. Movie의 주된 책임은 영화 요금을 계산하는 것이다. 
2. Screening의 가장 중요한 책임은 예매를 생성하는 것이다. 만약 둘이 협력하게 되면, Screening은 영화요금계산과 관련된 책임일부를 떠안아야한다. ⇒ 예매 요금 계산 변경될 경우 함께 변경되어야하고 응집도가 낮아진다. 

⇒ **응집도 관점에서 1번이 나은 대안이다.** 

<br>

### +창조자에게 객체 생성 책임을 할당하라

영화 예매 협력의 최종 결과물은 Reservation 인스턴스를 생성하는 것이다. 

GRASP의 CREATOR(창조자) 패턴은 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다. 

<br>

**CREATOR(창조자) 패턴**

- B가 A 객체를 포함하거나 참조한다.
- B가 A 객체를 기록한다.
- B가 A 객체를 긴밀하게 사용한다.
- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다.

위의 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라 

이 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.

이미 결합되어 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.

→ **이미 존재하는 객체 사이의 관계를 이용하기 때문에 낮은 결합도를 유지할수있다.** 

<br>

B에 해당하는 객체는 Screening이다. 

<br>

## 03. 구현을 통한 검증

Screening을 구현하자

: 예매할 책임을 맡으며 그 결과로 Reservation 인스턴스를 생성할 책임을 수행해야한다.

<br>

**[Screening]**

```java
public class Screening{
	private Movie movie;
	private int seauence;
	private LocalDateTime whenScreened;
	
	public Reservation reserve(Customer customer, int audienceCount){
		return new Reservation(custimer, this,calculateFee(audienceCount), audienceCount);
	}
	private Money calculateFee(int audienceCount){
		return movie.calculateMovieFee(this).times(audienceCount);
	}
}
```

**[인스턴스 변수]**

Movie에 가격을 계산하라 메시지를 전송해야하기 때문에 영화에 대한 참조 포함해야한다.

상영시간(whenScreened)과 상영순번(seauence)을 인스턴스 변수로 포함한다. 

<br>

**[메서드]**

예매하라는 메시지에 응답해야한다. → reserve함수

Movie에게 가격을 계산하라는 메시지를 전송해 계산된 영화요금을 반환받아야한다.

→ 이렇게 반환된 요금에 예매 인원수를 곱해서 전체 예매 요금을 계산한 후 Reservation을 생성해서 반환한다.

Screening을 구현하는 과정에서 Movie에 전송하는 메시지 시그니처를 calculateMovieFee(Screening screening)으로 선언했다는 사실에 주목하라

⇒ 수신자가 아니라 송신자인 Screening 의 의도를 표현했다. 

⇒ Screening 은 Movie의 구현을 고려하지 않고 전송할 메세지를 결정했다!

**⇒ Movie의 내부 구현은 깔끔하게 캡슐화되었다.**

<br>

<br>



**[Movie]**

```java
public class Movie{
	private String title;
	pricate Duration runningTime;
	private Money fee;
	private List<DiscountCondition> discountConditions;
	
	private MovieType movieType; // enum - 금액할인, 비율할인, 미적용
	private Money discountAmount;
	private double disountPercent;
	
	public Money calculateMovieFee(Screening screening){
		if(isDiscountable(screening)) return fee.minus(calculateDiscountAmount());
		}
		return fee
	}
	private boolean isDiscountable(Screening screening){
		return discountConditions.stream().anyMatch(condition-> condition.isSatisfieBy(screening));
	}
	private Money calculateDiscountAmount(){
		switch(movieType){
			case AMOUNT_DISCOUNT:
				return cacluateAmountDiscountAmount(); //return discountAmount; 
			case PERCENT_DISCOUNT:
				return cacluatePercentDiscountAmount();// return fee.times(discountPercent); 
			case NONE_DISCOUNT:
				return calculateNoneDiscountAmount(); //return Money.ZERO;
		}
	}
	//getWhenScreenined(),getSequence 추가 
}
```

**[인스턴스 변수]**

요금 계산을 위해 기본요금, 할인조건, 할인 정책을 알아야한다.

어떤 할인 정책이 적용될 영화인지 나타내기 위해 영화 종류를 포함한다. 

<br>


**[메서드]**

Movie 는 DiscountCondition에 할인 여부를 판단하라는 메시지를 전송한다. ⇒ isDiscountable

<br>

<br>



**[DiscountCondition]**

```java
public class DiscountCondition{
	private DiscountConditionType type;
	private int sequence;
	private DayOfWeek dayOfWeek;
	private LocalTime startTime;
	private LocalTime endTime;
	
	public boolean isSatisfiedBy(Screening screening){
		if(type == Discount(ConditionType.PERIOD) return isSatisfiedByPeriod(screening);
		return isSatisfiedBySequence(screening);
	}
	private boolean isSatisfiedByPeriod(Screening screening){
		...
	}
	private boolean isSatisfiedBySequence(Screening screening){
		...
	}
	
}
```
