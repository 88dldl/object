# 7장. 객체 분해

가장 일반적인 추상화 방법은 한 번에 다뤄야 하는 문제의 크기를 줄이는 것이다. ⇒ **분해**

분해의 목적은 큰 문제를 인지 과부하의 부담 없이 단기 기억 안에서 한 번에 처리할 수 있는 규모의 문제로 나누는 것이다, ( 하나의 단위로 취급될 수 있는 논리적인 청크를 의미한다 ) 

<br>

## 01. 프로시저 추상화와 데이터 추상화

**프로시저 추상화**는 소프트웨어가 무엇을 해야 하는지를 추상화한다.

**데이터 추상화**는 소프트웨어가 무엇을 알아야 하는지를 추상화한다. 

→ 소프트웨어는 데이터를 이용해 정보를 표현하고 프로시저를 이용해 데이터를 조작한다. 

**프로시저 추상화를 중심**으로 시스템 분해를 결정했다면 **기능분해(알고리즘 분해)**

**데이터 추상화를 중심**으로 시스템을 분해하기로 결정했다면 

1. **추상 데이터 타입** : 데이터를 중심으로 **타입**을 추상화 하거나 

2. **객체 지향** : 데이터를 중심으로 **프로시저**를 추상화하는 것이다. 

<br>

## 02. 프로시저 추상화와 기능 분해

### +메인 함수로서의 시스템

기능과 데이터 중 기능은 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용되었으며 이러한 시스템 분해 방식을 알고리즘 분해 (기능분해)라고 부른다. 

→ 추상화 단위는 프로시저이다.

<br>

**프로시저**는 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법이다. 

프로시저를 추상화라고 부르는 이유는 내부의 상세한 구현 내용을 모르더라도 인터페이스만 알면 프로시저를 사용할 수 있기 때문이다. 

→ 잠재적으로 정보은닉(information hiding)의 가능성을 제시하지만 프로시저만으로는 정보은닉을 구축하는 데는 한계가 있다. 

<br>

프로시저 중심의 기능 분해 관점에서 시스템은 입력 값을 계산해서 출력 값을 반환하는 수학의 함수와 동일하다. 시스템은 필요한 더 작은 작업으로 분해될 수 있는 하나의 커다란 메인 함수다.

<br>

전통적인 기능 분해 방법은 **하향식 접근법(Top-Down Approch)** 을 따른다. 

→ 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법이다. 

<br>

### + 급여 관리 시스템

```
급여 = 기본급 - (기본급 * 소득세율) //세율에 따라 일정 금액의 세금을 공제한다. 
```

하향식 접근법을 사용해 분해해 나가보자. 이 문장은 급여 관리 시스템을 시작하는 메인 프로시저로 구현될 것이다. 

<br>

```
직원의 급여를 계산한다. 
```

급여를 하는데 필요한 정보는 직원의 이름과 소득세율이다. 

```
직원의 급여를 계산한다.
	사용자로부터 소득세율을 입력받는다
	직원의 급여를 계산한다
	양식에 맞게 결과를 출력한다. 

```

급여 계산을 위해서는 직원의 기본급 정보도 필요하다

```
직원의 급여를 계산한다.
	사용자로부터 소득세율을 입력받는다
		"세율을 입력하세요 :"문장을 화면에 출력한다 .
		키보드를 통해 세율을 입력받는다. 
	직원의 급여를 계산한다
		전역변수에 저장된 직원의 기본급 정보를 얻는다. 
		급여를 계산한다. 
	양식에 맞게 결과를 출력한다. 
		"이름 : {직원명}, 급여 : {계산된 금액} 형식에 따라 출력 문자열을 생성한다. "
	
```

급여의 모든 절차를 나타내면 위와 같다. 

<br>

메인 함수에서 기능 분해를 시작했다. 기능 분해 방법에서는 기능을 중심으로 필요한 데이터를 결정한다. → 기능이 메인이고 데이터는 보조의 역할을 한다. 

⇒ 유지보수에 다양한 문제를 야기한다. 

<br>

### +하향식 기능 분해의 문제점

하향식 기능 분해 방법은 겉으로는 이상적인 방법으로 보일 수 있지만 실제로 설계에 적용하다 보면 다음과 같은 다양한 문제에 직면한다. 

- **시스템은 하나의 메인 함수로 구성돼 있지 않다.**
    - 대부분의 시스템에서 하나의 메인 기능이라는 개념은 존재하지 않는다.
- **기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야한다.**
    - 시스템 안에는 여러 개의 정상이 존재하기 떄문에 결과적으로 하나의 메인 함수를 유일한 정상으로 간주하는 이 경우에는 새로운 기능이 추가될 때 마다 매변 메인 함수를 수정해야 한다.  ⇒ 빈번한 수정은 버그 확률을 높인다.
- **비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.**
    - “사용자로부터 소득세율을 입력받아 급여를 계산한 후 계산된 결과를 화면에 출력한다”라는 말은 급여를 계산하는 중요한 비즈니스 로직과 관련된 관심사와 소득 세율을 입력받아 결과를 출력하는 사용자 인터페이스의 관심사가 섞여 있다.
- **하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저해된다.**
    - 설계를 시작하는 시점부터 시스템이 **무엇**을 해야 하는지가 아니라 **어떻게** 동작해야 하는지를 집중하도록 만든다. ⇒ 실행 순서를 정의하는 시간 제약을 강조한다. 실핼 순서나 조건, 반복과 같은 제어 구조를 미리 결정하지 않고는 분해를 진행할 수 없기 때문에 **중앙 집중 제어 스타일**의 형태를 띨 수밖에 없다.
    - 해결방법은 시간적인 제약에 대한 미련을 버리고 좀 더 안정적인 **논리적 제약**을 설계의 기준으로 삼는 것이다. ⇒ 여러 객체들 사이에 제어 주체가 분산된다.
- **데이터 형식이 변경될 경우 파급효과를 예측할 수 없다.**
    - 개별함수의 입장에서 사용하는 데이터를 파악하는 것은 어렵지 않다. 하지만 반대로 어떤 데이터가 어떤 함수에 의존하고 있는지를 파악하는 것은 어려운 일이다.
    - 데이터 변경으로 인한 영향을 최소화하려면 데이터와 함께 변경되는 부분과 그렇지 않는 부분을 명확하게 분리해야 한다. →잘 정의된 퍼블릭 인터페이스를 통해 데이터에 대한 접근을 통제해야 하는 것이다.
    
    ⇒ 이것의 **의존성 관리**의 핵심 !
    
    ⇒ 이런 개념을 기반으로 한 **정보 은닉**과 **모듈**이라는 개념을 제시하기도 했다.


<br>

### +언제 하향식 분해가 유용한가?

하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 방법이다. 그러나 하향식은 새로운 것을 개발하고 설계하고 발견하는데는 적합한 방법은 아니다.

<br>

## 03 모듈

### + 정보 은닉과 모듈

**모듈** : 책임의 할당. 작업이 시작되기 전에 정해져야하는 설계 결정들을 포함

**정보은닉** : 외부에 감춰야하는 비밀에 따라 시스템을 분할하는 모듈 분할 원리, 시스템에서 자주 변경되는 부분을 상대적으로 덜 변경되는 안정적인 인터페이스 뒤로 감춰야한다는 것이 핵심

<br>

모듈과 기능 분해는 상호 배타적인 관계가 아니다. 시스템을 모듈로 분해한 후에는 각 모듈 내부를 구현하기 위해 기능 분해를 적용할 수 있다.

기능 분해가 하나의 기능을 구현하기 위해 필요한 기능들을 순차적으로 찾아가는 탐색의 과정이라면 모듈 분해는 감춰야하는 비밀을 선택하고 비밀 주변에 안정적인 보호막을 설치하는 보존의 과정이다. 

<br>

시스템을 모듈 단위로 분해하려면, 시스템이 감춰야하는 비밀을 찾아라. 

→ 접근을 막기 위해 퍼블릭 인터페이스를 사용해라

<br>

모듈은 다음과 같은 두 가지 비밀을 감춰야한다. 

1. **복잡성** : 모듈이 너무 복잡한 경우 이해하고 사용하기가 어렵다. 외부에 모듈을 추상화할 수 있는 간단한 인터페이스를 제공해 모듈의 복잡도를 낮춘다.
2. **변경 가능성** :  변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다.

시스템의 가장 일반적인 비밀은 데이터이다. 비밀이 반드시 데이터일 필요는 없으며 복잡한 로직이나 변경 가능성이 큰 자료 구조일 수도 있다. (그럼에도 변경 시 시스템을 굴복시키는 대부분의 경우는 데이터가 변경되는 경우이다. )

<br>

급여 관리 시스템에서 사용할 수 있는 방법은 함께 사용되는 데이터를 자신의 비밀로 삼는 모듈을 만드는 것이다. 급여 관리 시스템에서 외부로 감춰야하는 비밀은 직원 정보와 관련된 것이다. 

**→ 모듈을 이용해 직원정보 비밀을 내부로 감추고 외부에는 퍼블릭 인터페이스만 노출시켜야 한다.**

<br>

c언어의 경우 소스파일에 모듈을 구현하고 이 중에서 외부에 공개할 부분은 헤더 파일에 external로 선언한다. 자바에서 모듈의 개념은 package를 이용해 구현이 가능하다. C++, C#에서는 namespace를 이용해 구현가능하다.
