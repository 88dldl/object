# 4장. 설계 품질과 트레이드오프

객체지향 설계의 핵심은 **역할, 책임, 협력**이다 

**협력**: 애플리케이션 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용

**책임** : 객체가 다른 객체와 협력하기 위해 수행하는 행동

**역할** : 대체 가능한 책임의 집합

저 중에서 가장 중요한 것은 **책임**이다.

⇒ 책임이 적절하게 할당되지 못하면 원할한 협력또한 기대 X

**객체지향설계**란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동

훌륭한 설계한 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.

결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙이 있다. → 객체의 상태가 아니라 행동에 초점을 맞추는 것!

⇒  객체의 상태에서 **행동**으로, 객체와 객체 사이의 상호작용으로 **설계 중심을 이동**시키고, **결합도가 낮고 응집도가 높으며** 구현을 효과적으로 캡슐화하는 객체들을 창조할 수 있는 기반 제공 

## 01. 데이터 중심의 영화 예매 시스템

객체지향 설계에서는 두 가지 방법의 이용해 시스템을 객체로 분할할 수 있다. 

1. 상태를 분할의 중심축으로 삼는다
2. 책임을 분할의 중심축으로 삼는다 

(상태는 객체가 저장해야하는 데이터의 집합을 의미하기에 여기서는 동일한 의미로 사용하겠다 )

데이터 중심의 관점에서 객체는 

자신이 포함하고 있는 데이터를 조작하는데 필요한 오퍼레이션을 정의한다. 

→ **객체의 상태**에 초점

→ 객체를 독립된 데이터 덩어리로 바라봄

책임중심의 관점에서 객체는

다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다. 

→ **객체의 행동**에 초점 

→ 객체를 협력하는 공동체의 일원으로 바라봄

훌륭한 객체지향 설계는 데이터가 아니라 책임에 초점을 맞추어야한다.

**객체의 상태**는 **구현**에 속한다. 구현은 불안정하기 떄문에 변하기 쉽다. 

⇒ 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스 사이에 스며들게 되어 캡슐화의 원칙이 무너진다

→ 인터페이스 변경을 초래하며 모든 객체에게 변경의 영향이 퍼진다. 

⇒ 변경에 취약!

<br>

### + 데이터를 기준으로 분할한 영화 예매 시스템

1장 Movie 클래스 참고

```java
public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private List<DistcountCondition> discountConditions;
    
    private MoneyType movieType;
    private Money discountAmount;
    private double discountPercent;
}
```

영화를 표현하는 기본적인 정보(영화제목, 상영시간 등)은 인스턴스 변수로 포함한다.

가장 두드러지는 차이점은 

- 할인 조건의 목록(discountConditions)의 인스턴스 변수로 Movie안에 직접 포함되어있다.
- 할인 정책을 할인금액(discountAmount)과 할인 비율(discountPercent)을 Movie안에서 직접 정의하고 있다. ⇒ 이전에는 할인 정책을 별도의 클래스로 분리했었음

할인 정책은 영화별로 하나만 지정할수있기 때문에 한 시점에 discountAmount와 discountPercent 중 하나의 값만 사용될 수있다. 

movieType으로 할인 정책의 종류를 결정한다. 

```java
public enum MovieType{
    AMOUNT_DISCOUNT,
    PERCENT_DISCOUNT,
    NONE_DISCOUNT;
}
```

데이터 중심의 설계는 객체가 **포함해야하는 데이터에 집중**한다. 

이 객체가 포함해야 하는 데이터는 무엇인가? 

→ 객체의 책임을 결정하기 전에 이런 질문의 반복에 휩쓸려 있다면 데이터 중심의 설계에 매몰돼 있을 확률이 높다.

⇒ 객체지향의 가장 중요한 원칙은 캡슐화이다. 이를 달성할 수 있는 가장 간단한 방법은 접근자(내부의 데이터 반환)와 수정자(데이터 변경)을 추가하는 것이다. 

⇒ getter,setter

<br>

## 02. 설계 트레이드오프

### 캡슐화

: 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류

: 상태와 행동을 하나의 객체안에 모으는 이유는 객체의 내부 구현(변경될 가능성이 높은 어떤것)을 외부로부터 감추기 위해서다. ⇒ 한곳에서 일어난 변경이 전체에 영향을 끼치지 않게 하기 위해 

: 객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것이다. 

### 응집과 결합도

: 응집도와 결합도는 구조적 설계 방법이 주도하던 시대에 소프트웨어의 품질을 측정하기 위해 소개된 기준이지만 객체지향의 시대에서도 여전히 유효하다.

응집도 : 모듈에 포함된 내부 요소들이 연관돼 있는 정도 <br>
→ 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.

결합도 : 의존성의 정도, 다른 모듈에 대해 얼마나 많이 알고 있는지 나타내는 척도 <br>
→ 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 가진다. 

좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다. 

⇒ 이를 위해서는 **높은 응집도**와 **낮은 결합도**를 추구해야한다.

<br>

**객체의 책임**은 **인터페이스**에 속한다. 객체는 책임을 드러내는 인터페이스 뒤로 

책임을 수행하는데 필요한 상태를 캡슐화 한다. ⇒ 구현 변경에 대한 파장이 외부로 퍼져나가는것을 방지 

→ 변경에 안정적인 설계 얻을수 있게 됨
