# 08. 의존성 관리하기

잘 설계된 객체지향 애플리케이션은 책임의 초점이 명확하고 한가지 일만 잘하는 객체들로들로 구성된다. 

이런 객체들이 단독으로 수행할 수 있는 작업은 거의 없기 떄문에 다른 객체에게 도움을 요청하고 이런 요청이 객체 사이의 협력을 낳는다. 

<br>

**협력**은 객체가 다른 객체에 대해 알 것을 강요한다. 

→ 이런 지식이 객체 사이의 **의존성**을 낳는다. 

<br>

협력을 위해서는 의존성이 필요하지만 과도한 의존성은 애플리케이션을 수정하기 어렵게 만든다. 

→ 객체지향 설계의 핵심은 협력을 위해 필요한 의존성을 유지하면서도 변경을 방해하는 의존성은 제거하는 데 있다.

 <br>

## 01. 의존성 이해하기

### + 변경과 의존성

의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다. 

**실행 시점** : 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.

**구현 시점** : 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다. 

<br>

영화 예매시스템의 PeriodCondition클래스를 보자

```java
public class PeriodCondition implements DiscountCondition{
	private DatOfWeek dayOfWeek;
	private LocalTime startTime;
	private LocalTime endTime;
	
	public boolean isSatisfiedBy(Screening screening){
		return screening.getStartTime().getDayOfWeek.equals(dayOfWeek) && 
			startTime.compareTo(screening.getStartTime().toLocalTime())<=0 &&
			endTime.compareTo(screening.getStartTime().toLocalTime())>=0 &&
	}
}
```

실행시점에서 PeriodCondition의 인스턴스가 정상적으로 동작하기 위해서는 Screening의 인스턴스가 존재해야한다. 

이처럼 어떠 객체에 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다. 

→ 의존성은 방향성을 가지며 항상 단방향이다. 

<br>

💡 PeriodCondition→ Screening,DayOfWeek,LocalTime

<br>

이처럼 PeriodCondition는 Screening,DayOfWeek,LocalTime에 의존한다. 

<br>

두 요소 사이의 의존성은 의존되는 요소가 변경될 때 **의존하는 요소도 함께 변경될 수 있다는 것**을 의미한다.
