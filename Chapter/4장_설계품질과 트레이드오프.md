# 4장. 설계 품질과 트레이드오프

객체지향 설계의 핵심은 **역할, 책임, 협력**이다 

**협력**: 애플리케이션 기능을 구현하기 위해 메시지를 주고받는 객체들 사이의 상호작용

**책임** : 객체가 다른 객체와 협력하기 위해 수행하는 행동

**역할** : 대체 가능한 책임의 집합

저 중에서 가장 중요한 것은 **책임**이다.

⇒ 책임이 적절하게 할당되지 못하면 원할한 협력또한 기대 X

**객체지향설계**란 올바른 객체에게 올바른 책임을 할당하면서 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동

훌륭한 설계한 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.

결합도와 응집도를 합리적인 수준으로 유지할 수 있는 중요한 원칙이 있다. → 객체의 상태가 아니라 행동에 초점을 맞추는 것!

⇒  객체의 상태에서 **행동**으로, 객체와 객체 사이의 상호작용으로 **설계 중심을 이동**시키고, **결합도가 낮고 응집도가 높으며** 구현을 효과적으로 캡슐화하는 객체들을 창조할 수 있는 기반 제공 

## 01. 데이터 중심의 영화 예매 시스템

객체지향 설계에서는 두 가지 방법의 이용해 시스템을 객체로 분할할 수 있다. 

1. 상태를 분할의 중심축으로 삼는다
2. 책임을 분할의 중심축으로 삼는다 

(상태는 객체가 저장해야하는 데이터의 집합을 의미하기에 여기서는 동일한 의미로 사용하겠다 )

데이터 중심의 관점에서 객체는 

자신이 포함하고 있는 데이터를 조작하는데 필요한 오퍼레이션을 정의한다. 

→ **객체의 상태**에 초점

→ 객체를 독립된 데이터 덩어리로 바라봄

책임중심의 관점에서 객체는

다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태를 보관한다. 

→ **객체의 행동**에 초점 

→ 객체를 협력하는 공동체의 일원으로 바라봄

훌륭한 객체지향 설계는 데이터가 아니라 책임에 초점을 맞추어야한다.

**객체의 상태**는 **구현**에 속한다. 구현은 불안정하기 떄문에 변하기 쉽다. 

⇒ 상태를 객체 분할의 중심축으로 삼으면 구현에 관한 세부사항이 객체의 인터페이스 사이에 스며들게 되어 캡슐화의 원칙이 무너진다

→ 인터페이스 변경을 초래하며 모든 객체에게 변경의 영향이 퍼진다. 

⇒ 변경에 취약!

<br>

### + 데이터를 기준으로 분할한 영화 예매 시스템

1장 Movie 클래스 참고

```java
public class Movie {
    private String title;
    private Duration runningTime;
    private Money fee;
    private List<DistcountCondition> discountConditions;
    
    private MoneyType movieType;
    private Money discountAmount;
    private double discountPercent;
}
```

영화를 표현하는 기본적인 정보(영화제목, 상영시간 등)은 인스턴스 변수로 포함한다.

가장 두드러지는 차이점은 

- 할인 조건의 목록(discountConditions)의 인스턴스 변수로 Movie안에 직접 포함되어있다.
- 할인 정책을 할인금액(discountAmount)과 할인 비율(discountPercent)을 Movie안에서 직접 정의하고 있다. ⇒ 이전에는 할인 정책을 별도의 클래스로 분리했었음

할인 정책은 영화별로 하나만 지정할수있기 때문에 한 시점에 discountAmount와 discountPercent 중 하나의 값만 사용될 수있다. 

movieType으로 할인 정책의 종류를 결정한다. 

```java
public enum MovieType{
    AMOUNT_DISCOUNT,
    PERCENT_DISCOUNT,
    NONE_DISCOUNT;
}
```

데이터 중심의 설계는 객체가 **포함해야하는 데이터에 집중**한다. 

이 객체가 포함해야 하는 데이터는 무엇인가? 

→ 객체의 책임을 결정하기 전에 이런 질문의 반복에 휩쓸려 있다면 데이터 중심의 설계에 매몰돼 있을 확률이 높다.

⇒ 객체지향의 가장 중요한 원칙은 캡슐화이다. 이를 달성할 수 있는 가장 간단한 방법은 접근자(내부의 데이터 반환)와 수정자(데이터 변경)을 추가하는 것이다. 

⇒ getter,setter

<br>

## 02. 설계 트레이드오프

### + 캡슐화

: 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류

: 상태와 행동을 하나의 객체안에 모으는 이유는 객체의 내부 구현(변경될 가능성이 높은 어떤것)을 외부로부터 감추기 위해서다. ⇒ 한곳에서 일어난 변경이 전체에 영향을 끼치지 않게 하기 위해 

: 객체지향 설계의 가장 중요한 원리는 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로 캡슐화하는 것이다. 

### + 응집과 결합도

: 응집도와 결합도는 구조적 설계 방법이 주도하던 시대에 소프트웨어의 품질을 측정하기 위해 소개된 기준이지만 객체지향의 시대에서도 여전히 유효하다.

**응집도** : 모듈에 포함된 내부 요소들이 연관돼 있는 정도 <br>
→ 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.

**결합도** : 의존성의 정도, 다른 모듈에 대해 얼마나 많이 알고 있는지 나타내는 척도 <br>
→ 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 가진다. 

좋은 설계란 오늘의 기능을 수행하면서 내일의 변경을 수용할 수 있는 설계다. 

⇒ 이를 위해서는 **높은 응집도**와 **낮은 결합도**를 추구해야한다.

<br>

**객체의 책임**은 **인터페이스**에 속한다. 객체는 책임을 드러내는 인터페이스 뒤로 

책임을 수행하는데 필요한 상태를 캡슐화 한다. ⇒ 구현 변경에 대한 파장이 외부로 퍼져나가는것을 방지 

→ 변경에 안정적인 설계 얻을수 있게 됨
<br>

- 이를 추구해야하는 이유 → 이것이 설계를 변경하기 쉽게 만들기 때문이다.
- 변경의 관점에서 응집도란 변경이 발생할때 모듈 내부에서 발생하는 변경의 정도를 측정할 수 있다.

<br>

[이게 뭔말일까]

- 하나의 변경에 대해 하나의 모듈만 변경된다면 응집도가 높지만 다수이 모듈이 함께 변경돼야 한다면 응집도가 낮은것 
- 결합도가 높아도 상관없는 경우 → 변경될 확률이 매우 적은 안정적인 모듈에 의존할때

ex) 표준 라이브러리에 포함된 모듈이나 성숙 단계에 접어든 프레임워크에 의존하는 경우 <br> → 자바 String, ArrayList 

<br>

하지만, 직접 작성한 코드는 항상 불안정하고 언제라도 변경될 가능성이 높다 

**캡슐화의 정도가 응집도와 결합도에 영향을 미친다.**
- 캡슐화를 지키면 모듈안의 응집도는 높아지고 모듈화의 결합도는 낮아진다. 
- 응집도와 결합도를 고려하기 전에 캡슐화를 형상시키기 위해 노력하라

<br>

## 03. 데이터 중심의 영화 예매 시스템의 문제점

데이터 중심의 설계가 가지는 대표적인 문제점

- 캡슐화 위반
- 높은 결합도
- 낮은 응집도

<br>

### + 캡슐화 위반

```java
public class M{
	private M fee;
	
	pubic M getf(){
		return fee;
	}
	
	pubic void setf(M fee){
		this.fee = fee;
	}
	
}
```

getter, setter로만 값을 읽고 수정할 수 있다고 할 때, 직접 객체의 내부에 접근할수없기 때문에 캡슐화의 원칙을 지키고 있는것처럼 보인다.

⇒  M내부의 M타입의 f라는 이름의 인스턴스 변수가 존재한다는 사실을 퍼블릭 인터페이스에 노골적으로 드러낸다 

캡슐화 원칙을 어기게 된 근본적인 원인 : 객체가 수행할 책임이 아니라 내부에 저장할 데이터에 초점을 맞췄기 때문! <br> ⇒ **책임**에 초점을 두자

<br>

앨러 홀럽은 이처럼 접근자와 수정자에게 과하게 의존하는 설계방식을

**추측에 의한 설계전략** 이라고 부른다

→ 이렇게 되면 캡슐화 원칙을 위반하는 변경에 취약한 설계를 얻게 된다. 

<br>

### + 높은 결합도

위의 코드에서 객체의 내부 구현을 변경했음에도 이 인터페이스에 의존하는 모든 클라이언트들도 함께 변경을 해야한다. 

ex)

다른클래스에서 M타입의 fee를 저장한 후 getf,setf 메서드를 사용해 값을 불러오고 저장한다고 가정한다. 

이때 fee의 타입을 변경한다고 하면 

1. getf 메서드 반환 타입 수정
2. 다른 클래스의 구현도 변경된 타입에 맞게 수정

이 필요하다.

→ fee타입 변경으로 인해 협력하는 클래스가 변경되기 떄문에 getf 메서드는 fee를 정상적으로 캡슐화하지 못한다. 

→ 사실상 getf의 메서드를 사용하는 것은 변수 fee의 가시성을 public으로 변경하는 것과 동일하다 

⇒ 클라이언트가 객체의 구현에 강하게 결합되어있다 = **객체의 캡슐화 약화**

<br>

결합도 측면에서 데이터 중심 설계가 가지는 또 다른 단점

- 여러 데이터 객체들을 사용하는 제어 로직이 특정 객체 안에 집중된다 → 하나의 제어 객체가 다수의 데이터 객체에 강하게 결합된다 ⇒ 이 결합도로 인해 캡슐화가 약화된다.
    
    ex) ReservationAgency 클래스

<br>

### + 낮은 응집도

서로 다른 이유로 변경되는 코드가 하나의 모듈안에 공존할 때 모듈의 응집도가 낮다고 한다 

→ 변경의 이유가 다른 코드들을 하나의 모듈안에 뭉쳐놓으면 변경과 아무런 상관이 없는 코드들이 영향을 받는다.

→ 하나의 요구사항을 변경하기 위해 동시에 여러 모듈들을 수정해야한다. ⇒ 다른 모듈에 위치해야할 책임의 일부가 엉뚱한 곳에 위치할수있다. 

<br>

**+) 단일책임 원칙**
: 클래스는 단 한가지 변경이유만 가져야한다.

: 로버트 마틴이 제시

<br>
<br>

## 04. 자율적인 객체를 향해

### + 캡슐화를 지켜라

캡슐화는 설계의 **제1원리**이다. 

객체는 스스로의 상태를 책임져야하며 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.

<br>
<br>

## 05. 하지만 여전히 부족하다

### + 캡슐화 위반

```java
public class Discount{
	privae DiscountType type;
	private int sequence;
	private DayOfWeek dayOfWeek;
	private LocalTime startTime;
	private LocalTi,e endTime;
	
	public DiscountType getType(){...}
	
	public boolean isDiscountable(DayOfWeek dayOfWeek, LocalTime time){...}
	
	public boolean isDiscountable(int sequence){...}
}
```

: 속성으로 포함되어있는 DayOfWeek 타입의 요일정보와 LocalTime 타입의 시간 정보가 인스턴스 변수로 포함되어있다는 사실을 인터페이스를 통해 외부에 노출 중이다. 

: int 타입의 순번 정보를 포함하고 있다는 사실을 알 수 있다. 

: getType 메서드를 통해 내부에 DiscountType 을 포함하고 있다는 정보도 노출 중이다. .

<aside>
 만약 DiscountCondition의 속성을 변경해야 한다면 어떻게 될까?
</aside>

<br>

→ 메서드의 파라미터를 수정하고, 해당 메서드를 사용하는 모든 클라이언트들도 함께 수정해야한다.

→ 파급효과는 캡슐화가 부족하다는 명백한 증거이다. 

⇒ 내부의 구현을 **캡슐화하는데 실패**했다. 


```java
public class Movie{
	private String title;
	private Duration runningTime;
	private Money fee;
	private List<DiscountCondition> discountConditions;
	
	private MovieType movieType;
	private Money discountAmount;
	private double discountPercent;
	
	private MovieType getmovieType(){...};
	private Money calculateAmountDiscountFee(){...};
	private Money calculatePercentDiscountFee(){...};
	private Money calculateNoneDiscountFee(){...};

```

그렇다면 이건 좀 다른가?

<br>

객체의 파라미터나 반환 값으로 내부에 포함된 속성에 대한 어떤 정보도 노출하고 있지 않다.

⇒ 캡슐화의 원칙을 지키고 있다.  하지만, Movie 역시 내부 구현을 인터페이스에 노출시키고 있다. ⇒ 할인종류!

세개의 메서드에는 할인 정책에는 금액, 비율, 미적용 할인 정책이 존재한다는 것을 알린다. 

⇒ 만약 새로운 할인 정책이 추가된다면 이 메서드에 의존하는 모든 클라이언트가 영향을 받는다. 

⇒ 결과적으로 **성공적으로 캡슐화하지 못했다.**

<br>


**캡슐화란 변할 수 있는 어떤 것이라도 감추는 것이다. 그것이 무엇이든 구현과 관련된 것이라면 말이다.**

<br>


### + 높은 결합도

캡슐화 위반으로 구현이 노출되었다면 결합도는 높을 수 밖에 없다

```java
public class Movie{
	public boolean isDiscountable(LocalDateTime whenScreened, int sequence){
		for(DiscountCondition condition : discountConditions){
			if(condition.getType()==DiscountConditionType.PERIOD){
				if(condition.isDiscountable(whenScreened.getDayOfWeek(),whenScreened.toLocalTime()){
					return true;
				}
			}
			else{
				if(condition.isDiscountable(sequence)){
					return true;
				}
			}
		}
		return false;
	}
}
```

- condition 의 종류가 추가되거나 삭제되면 if 문이 수정되어야한다.
- 기간 할인조건의 명칭이 period에서 다른 값으로 변경되면 수정해야한다.
- 각 DiscountCondition의 만족여부를 판단하는데 필요한 정보가 변경되면 isDiscountable로 전달된 파라미터를 변경해야하고, 이로인해 매서드 시그니처가 변경될것이고, 이 매서드에 의존하는 것들에 대한 변경을 초래한다.
  
  <br>


### + 낮은응집도

```java
public class Screening{
	public Money caculateFee(int audienceCount){
		switch(movie.getMovieType()){
			case AMOUNT_DISCOUNT:
				if(movie.isDiscountable(whenScreened, sequence)){
					return movie.caculateAmountDiscountedFee().times(audienceCount);
				}
			case PERCENT_DISCOUNT:
			...
		}
	}

}
```

할인 조건의 종류를 변경하기 위해서는 DiscountCondition, Movie, Screening 을 함께 수정해야함

→ 하나의 변경을 수용하기 위해 여러곳을 동시에 바꿈 

→ 응집도 낮다는 증거

→ 캡슐화를 위반했기 때문 !

DiscountCondition과 Movie의 내부 구현이 인터페이스에 그대로 노출되고 있고, Screening 은 노출된 구현에 직접적으로 의존하고 있다. 

= DiscountCondition이나 Movie에 위치해야하는 로직이 Screening으로 새어나온 것

<br>
<br>



## 06. 데이터 중심 설계의 문제점

데이터 중심 설계가 변경에 취약한 이유

: 데이터 중심의 설계는 본지적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다

: 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고  객체를 고립시킨채 오퍼레이션을 진행한다. 

<br>


### + 데이터 중심 설계는 객체의 행동보다는 상태에 초점을 맞춘다.

1. 데이터 중심의 관점에서 객체는 그저 단순한 데이터의 집합체일 뿐이다

→ 접근자와 수정자를 과도하게 추가하게 되고 , 이 데이터 객체를 사용하는 절차를 분리된 별도의 객체 안에 구현하게 된다. 

⇒ 접근자와 수정자는 public 속성과 큰 차이가 없기 떄문에 객체의 캡슐화는 완전히 무너질수밖에 없다. 

1. 데이터를 먼저 결정하고 데이터를 처리하는데 필요한 오퍼레이션을 추가하는 방식은 데이터에 관한 지식이 객체의 인터페이스에 고스란히 드러나게 된다. 

→ 결과적으로 객체의 인터페이스는 구현을 캡슐화하는데 실패하고 코드의 변경에 취약해진다. 

<br>

### + 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다.

객체지향 애플리캐이션을 구현한다는 것 = **협력하는 객체들의 공동체를 구축한다는 것**
