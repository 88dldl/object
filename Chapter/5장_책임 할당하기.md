# 5장. 책임 할당하기

책임 할당 과정은 일종의 트레이드오프 활동이다. 동일한 문제를 해결할 수 있는 다양한 책임 할당 방법이 존재하며, 어떤 방법이 최선인지는 상황과 문맥에 따라 달라진다. 

<br>

## 01. 책임 주도 설계를 위해

데이터 중심 설계 → 책임 주도 설계로 전환하기 위해 따라야하는 원칙

- 데이터 보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

<br>

### + 데이터보다 행동을 먼저 결정하라

객체에게 중요한 것은 **외부에 제공하는 행동**이다. 

클라이언트 관점에서 객체가 수행하는 행동이란 곧 **객체의 책임**을 의미한다.

데이터는 객체가 책임을 수행하는 데 필요한 재료를 제공할 뿐이다.

<br>

**[객체의 데이터에서 행동으로 무게 중심을 옮기기 위한 기법]**

→ 객체를 설계하기 위한 질문이 순서를 바꾸기 

“이 객체가 포함해야하는 데이터가 무엇인가”→ “데이터를 처리하는데 필요한 오퍼레이션은 무엇인가”

책임 중심의 설계에서는 객체의 행동, 즉 *책임을 먼저 결정한 후에 객체의 상태를 결정*한다.

<br>

### +협력이라는 문맥 안에서 책임을 결정하라

**객체에게 할당된 책임의 품질은 협력에 적합한 정도로 결정된다.**

→ 책임이 협력에 어울리지 않는다면 그 책임은 나쁜 것이다.

→ 책임이 조금 어색해 보이더라도 협력에 적합하다면 그 책임은 좋은 것이다. 
<br>

협력에 적합한 책임이란 메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 의미함

→ 메시지를 전송하는 클라이언트의 의도에 적합한 책임을 할당해야 한다.

<br>

**메시지를 결정한 후에 객체를 선택하라**

메시지가 존재하기 때문에 그 메시지를 처리할 객체가 필요한 것이다. 
⇒ 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.
메시지가 **클라이언트의 의도를 표현**한다

- 클라이언트는 단지 임의의 객체가 메시지를 수신할 것이라는 사실을 믿고 자신의 의도를 표현한 메시지를 전송할 뿐이다.
- 그리고 메시지를 수신하기로 결정된 객체는 메시지를 처리할 책임을 할당받게 된다.

⇒ 메시지 전송자의 관점에서는 메시지 수신자가 깔끔하게 **캡슐화**되는것이다. 

책임중심의 설계가 응집도가 높고 결합도가 낮으며 변경하기 쉽다고 말하는 이유가 여기에 있다. 

<br>

**객체에게 적절한 책임을 할당하기 위해서는 협력이라는 문맥을 고려해야한다.**

협력이라는 문맥에서 적절한 책임이란 곧 클라이언트의 관점에서 적절한 책임을 의미한다. 

⇒ 3장에서 소개한 **책임 주도 설계 방법**의 핵심과 거의 동일하다 !

<br>

### + 책임 주도 설계

3장에서 나온 책임 주도 설계의 흐름

- 시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다
- 시스템 책임을 더 작은 책임으로 분할한다
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 하당한다
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 된다.

<br>

### +정보 전문가에게 책임을 할당하라

: 책임 주도 설계 방식에서의 첫 단계는 애플리케이션이 제공해야하는 기능을 애플리케이션의 책임으로 생각하는 것이다. 

→ 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고, 이 메시지를 첫번째 객체를 선택하는 것으로 설계 시작

<br>

<br>

## 02. 책임할당을 위한 GRASP 패턴

**GRASP** : General Responsibility Assignment Software Pattern (**일반적인 책임할당을 위한 소프트웨어 패턴**)

<br>

### +도메인 개념에서 출발하기

: 도메인 안에는 무수히 많은 개념들이 존재하며 이 도메인 개념들을 책임 할당의 대상으로 사용하면 코드에 도메인 모습을 투영하기가 좀 더 수월해진다. 

: 설계를 시작하는 단계에서는 개념들의 의미와 관계가 정확하거나 완벽할 필요가 없다.

: 도메인 개념을 정리하는데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행하라
 앞서 나온 영화 예매 시스템을 생각해보자

: 사용자에게 제공해야하는 기능은 영화를 예매하는 것이다.  ⇒ 애플리케이션은 영화를 예매할 책임이 있다. 

이제 이 책임을 수행하는데 필요한 메시지를 결정해야한다. (메시지를 전송할 객체의 의도를 반영해서 결정)

1. 메시지를 전송할 객체는 무엇을 원하는가 ⇒ **“예매하라”**
2. 메시지를 수신하 적합한 객체는 누구인가

이 질문에 답하기 위해 객체가 상태와 행동을 통합한 캡슐화의 단위라는것에 집중해야한다. 

→ 자신의 상태를 스스로 처리하는 자율적인 존재여야한다. 

<br>

**객체에게 책임을 할당하는 첫번째 원칙 : INFORMATION EXPERT (정보 전문가) 패턴**

객체의 책임과 책임을 수행하는데 필요한 상태는 동일한 객체 안에 존재해야한다.

⇒ **책임을 수행할 정보를 알고있는 객체에게 책임을 할당하는 것**이다. 

- 정보와 행동을 최대한 가까운 곳에 위치시키기 때문에 캡슐화 유지 가능
- 필요한 정보를 가진 객체들로 책임이 분산되기 때문에 더 응집력있고 이해하기 쉬워짐
- 결합도가 낮아져서 간결하고 유지보수하기 쉬운 시스템 구축 가능
- 책임을 수행하는 객체가 정보를 알고있다고 해서 그 정보를 저장할 필요는 없다 → 정보를 제공하는 객체를 알고 있거나 계산을 통해 제공할 수도 있다.

<br>

예매하는데 필요한정보를 가장 많이 알고있는 **Screening이라는 객체에 *예매하라* 를 할당**해야한다. 

예매하라를 처리하기 위해서는 예매 가격을 계산해야하고 Screening은 가격을 계산하는데 필요한 정보를 모르기 때문에 외부객체에 도움을 요청해서 가격을 얻어야한다. 

  ⇒ ***계산하라***

계산을 처리하기 위해 **할인 여부를 판단**해야하고 위 방식과 동일하게 진행된다 .

<br>


### +높은 응집도와 낮은 결합도

설계는 트레이드오프 활동이다. → 동이한 기능을 구현할 수 있는 무수한 설계가 존재하고 이 중 한 가지를 선택해야하는 경우가 빈번함

위에서는 Movie가 할인 여부를 판단하라는 메시지를 전송한다. 

→ Screening이 DiscountCondition과 협력하는것은 어떨까 

⇒ Screening에서 할인 여부를 판단하라는 메시지를 전송하고, 반환받은 할인여부를 Movie에 인자로 전달하는 것이다. 이 전달받은 값을 이용해 할인정책을 적용하여 계산하는지 결정하는 것이다. 

<br>

**LOW COUPLING (낮은 결합도) 패턴과 HIGH COHESION ( 높은 응집도) 패턴**

1. 도메인상으로는 Movie가 DiscountCondition 목록을 포함하고 있어 결합도를 추가하지 않고 협력가능하다 
2. Screening이 DiscountCondition과 협력하게 되면 새로운 결합도가 추가된다. 

⇒ **결합도 관점에서는 1번이 나은 대안이다.** 

<br>

1. Movie의 주된 책임은 영화 요금을 계산하는 것이다. 
2. Screening의 가장 중요한 책임은 예매를 생성하는 것이다. 만약 둘이 협력하게 되면, Screening은 영화요금계산과 관련된 책임일부를 떠안아야한다. ⇒ 예매 요금 계산 변경될 경우 함께 변경되어야하고 응집도가 낮아진다. 

⇒ **응집도 관점에서 1번이 나은 대안이다.** 

<br>

### +창조자에게 객체 생성 책임을 할당하라

영화 예매 협력의 최종 결과물은 Reservation 인스턴스를 생성하는 것이다. 

GRASP의 CREATOR(창조자) 패턴은 객체를 생성할 책임을 어떤 객체에게 할당할지에 대한 지침을 제공한다. 

<br>

**CREATOR(창조자) 패턴**

- B가 A 객체를 포함하거나 참조한다.
- B가 A 객체를 기록한다.
- B가 A 객체를 긴밀하게 사용한다.
- B가 A 객체를 초기화하는 데 필요한 데이터를 가지고 있다.

위의 조건을 최대한 많이 만족하는 B에게 객체 생성 책임을 할당하라 

이 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 있는 객체에 해당 객체를 생성할 책임을 맡기는 것이다.

이미 결합되어 있는 객체에게 생성 책임을 할당하는 것은 설계의 전체적인 결합도에 영향을 미치지 않는다.

→ **이미 존재하는 객체 사이의 관계를 이용하기 때문에 낮은 결합도를 유지할수있다.** 

<br>

B에 해당하는 객체는 Screening이다. 

<br>

## 03. 구현을 통한 검증

Screening을 구현하자

: 예매할 책임을 맡으며 그 결과로 Reservation 인스턴스를 생성할 책임을 수행해야한다.

<br>

**[Screening]**

```java
public class Screening{
	private Movie movie;
	private int seauence;
	private LocalDateTime whenScreened;
	
	public Reservation reserve(Customer customer, int audienceCount){
		return new Reservation(custimer, this,calculateFee(audienceCount), audienceCount);
	}
	private Money calculateFee(int audienceCount){
		return movie.calculateMovieFee(this).times(audienceCount);
	}
}
```

**[인스턴스 변수]**

Movie에 가격을 계산하라 메시지를 전송해야하기 때문에 영화에 대한 참조 포함해야한다.

상영시간(whenScreened)과 상영순번(seauence)을 인스턴스 변수로 포함한다. 

<br>

**[메서드]**

예매하라는 메시지에 응답해야한다. → reserve함수

Movie에게 가격을 계산하라는 메시지를 전송해 계산된 영화요금을 반환받아야한다.

→ 이렇게 반환된 요금에 예매 인원수를 곱해서 전체 예매 요금을 계산한 후 Reservation을 생성해서 반환한다.

Screening을 구현하는 과정에서 Movie에 전송하는 메시지 시그니처를 calculateMovieFee(Screening screening)으로 선언했다는 사실에 주목하라

⇒ 수신자가 아니라 송신자인 Screening 의 의도를 표현했다. 

⇒ Screening 은 Movie의 구현을 고려하지 않고 전송할 메세지를 결정했다!

**⇒ Movie의 내부 구현은 깔끔하게 캡슐화되었다.**

<br>

<br>



**[Movie]**

```java
public class Movie{
	private String title;
	pricate Duration runningTime;
	private Money fee;
	private List<DiscountCondition> discountConditions;
	
	private MovieType movieType; // enum - 금액할인, 비율할인, 미적용
	private Money discountAmount;
	private double disountPercent;
	
	public Money calculateMovieFee(Screening screening){
		if(isDiscountable(screening)) return fee.minus(calculateDiscountAmount());
		}
		return fee
	}
	private boolean isDiscountable(Screening screening){
		return discountConditions.stream().anyMatch(condition-> condition.isSatisfieBy(screening));
	}
	private Money calculateDiscountAmount(){
		switch(movieType){
			case AMOUNT_DISCOUNT:
				return cacluateAmountDiscountAmount(); //return discountAmount; 
			case PERCENT_DISCOUNT:
				return cacluatePercentDiscountAmount();// return fee.times(discountPercent); 
			case NONE_DISCOUNT:
				return calculateNoneDiscountAmount(); //return Money.ZERO;
		}
	}
	//getWhenScreenined(),getSequence 추가 
}
```

**[인스턴스 변수]**

요금 계산을 위해 기본요금, 할인조건, 할인 정책을 알아야한다.

어떤 할인 정책이 적용될 영화인지 나타내기 위해 영화 종류를 포함한다. 

<br>


**[메서드]**

Movie 는 DiscountCondition에 할인 여부를 판단하라는 메시지를 전송한다. ⇒ isDiscountable

<br>

<br>



**[DiscountCondition]**

```java
public class DiscountCondition{
	private DiscountConditionType type;
	private int sequence;
	private DayOfWeek dayOfWeek;
	private LocalTime startTime;
	private LocalTime endTime;
	
	public boolean isSatisfiedBy(Screening screening){
		if(type == Discount(ConditionType.PERIOD) return isSatisfiedByPeriod(screening);
		return isSatisfiedBySequence(screening);
	}
	private boolean isSatisfiedByPeriod(Screening screening){
		...
	}
	private boolean isSatisfiedBySequence(Screening screening){
		...
	}
	
}
```
<br>

### +DiscountCondition 개선하기

가장 큰 문제점은 변경에 취약한 클래스를 포함하고 있다는 것이다. 

1. 새로운 할인 조건 추가 : isSatisfiedBy 메서드 안 if~else구문을 수정해야한다. 그리고 새로운 할인 조건이 새로운 데이터를 요구하면 속성을 추가하는 작업도 필요하다. 
2. 순번 조건을 판단하는 로직 변경 : 순번 조건을 판단하는데 필요한 데이터가 변경되면 속성이 변경되어야한다. 
3. 기간 조건을 판단하는 로직이 변경되는 경우 : 데이터 변경 수정 및 속성추가 필요

⇒ 응집도가 낮다, 

⇒ 서로 연관성 없는 기능이나 데이터가 하나의 클래스 안에 뭉쳐있다.

<br>

isSatisfiedBySequence와 isSatisfiedByPeriod는 서로 다른 이유로 변경된다. 

⇒ 두가지 변경은 코드에 영향을 미치는 시점이 다를 수 있고, 서로 다른 이유로 변경되는 두 개의 메서드를 가지는 클래스의 **응집도는 낮아질 수 밖에 없다.**

<br>

**코드를 통해 변경의 이유를 파악할 수 있는 방법**
1. 인스턴스 변수가 초기화되는 시점을 살펴본다. : 응집도가 높은 클래스는 인스턴스를 생성할떄 모든 속성을 함께 초기화 한다. 
2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴본다 : 모든 메서드가 모든 속성을 사용한다면 클래스의 응집도가 높다고 볼 수 있다.

<br>

### +타입 분리하기

DiscountCondition의 가장 큰 문제는 순번 조건과 기간 조건이라는 두 개의 독립적인 타입이 하나의 클래스 안에 공존하고 있다는 것이다. 

**⇒ 해결방법 1 : 두개의 클래스로 분리하자**

```java
public class PeriodCondition{
	private DayOfWeek dayOfWeek;
	private LocalTime startTime;
	private LocalTime endTime;
	
	// 생성자
	private boolean isSatisfiedByPeriod(Screening screening){
		...
	}
```

```java
public class SequenceCondition{
	private int sequence;
	
	// 생성자
	public boolean isSatisfieBy(Screening screening){
		return sequence == screening.getSequence();
	}
	
```

이렇게 분리하며 앞서 언급했던 문제점들이 모두 해결되었다. 

→**코드의 품질을 높였다.** 

근데, 새로운 문제가 나타났다.

수정전에는 Movie와 협력하는 클래스는 DiscountCondition 하나였다. 

 → 수정 후 Movie의 인스턴스는 PeriodCondition과 SequenceCondition 둘 다 협력해야한다.

<br>

<br>

이 문제를 해결하기 위해 생각할 수 있는 첫번째 방법은 Movie 클래스 안에서 두 클래스의 목록을 유지하는 것이다.

```java
private List<PeriodCondition> periodConditions;
private List<SequenceCondition> sequenceConditions;
```

하지만, 이 방법은 새로운 문제를 야기한다. 

1. **Movie클래스가 두 클래스 모두에게 결합된다 ⇒ 결합도 높아짐**
2. 새로운 할인 조건을 추가하기 어려워졌다. ⇒ 새로운 조건 클래스를 담기 위해 List를 Movie의 인스턴스 변수로 추가해야한다. + 할인조건을 만족하는지 여부를 판단하는 메서드도 추가해야한다. + 이 메서드를 호출하도록 isDiscountable 메서드를 수정해야한다.

<br>

DiscountCondition의 입장에서 보면 응집도는 높아졌으나 변경과 캡슐화 관점에서 보면 전체적으로 설계의 품질이 나빠졌다.

<br>

### +다형성을 통해 분리하기

사실 Movie입장에서 보면 SequenceCondition과 PeriodCondition은 아무 차이가 없다.

→ 둘 모두 할인 여부를 판단하는 동일한 책임을 수행하고 있다. 

<br>

Movie의 입장에서는 할인 여부를 판단하기 위해 사용하는 방법이 서로 다르다는 사실과 어떤 인스턴스인지는 Movie입장에서 그다지 중요하지 않다. 

⇒ Movie가 구체적인 클래스는 알지 못하게 오직 **역할에 대해서만 결합**되도록 의존성을 제한하자. 

<br>

**DiscountCondition(interface) : Period Condition/ Sequence Condition**

그래서 Movie는 DiscountCondition과 결합하도록 하자 

⇒ **추상화** 가능해짐, 다형성 패턴이 적용되었다. 

<br>

**다형성(POLYMORPHISM) 패턴**

객체의 타입에 따라 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당한다.
